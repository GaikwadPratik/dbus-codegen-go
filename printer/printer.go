package printer

import (
	"errors"
	"fmt"
	"go/format"
	gotoken "go/token"
	"io"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/amenzhinsky/dbus-codegen-go/token"
)

// PrintOption is a Print configuration option.
type PrintOption func(p *printer)

type printer struct {
	buffer

	pkgName  string
	gofmt    bool
	prefixes []string
}

// WithPackageName overrides the package name of generated code.
func WithPackageName(name string) PrintOption {
	return func(p *printer) {
		p.pkgName = name
	}
}

// WithGofmt gofmts generated code, enabled by default.
//
// Not recommended to disable it, only for debugging the output,
// because gofmt works as a validation step as well.
func WithGofmt(enable bool) PrintOption {
	return func(p *printer) {
		p.gofmt = enable
	}
}

// WithPrefixes prefixes to strip from interface names, be careful
// when using it may lead to compilation errors.
func WithPrefixes(prefixes []string) PrintOption {
	return func(p *printer) {
		p.prefixes = prefixes
	}
}

var identRegexp = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]*$")

// Print generates code for the provided interfaces and writes it to out.
func Print(out io.Writer, ifaces []*token.Interface, opts ...PrintOption) error {
	p := &printer{
		pkgName: "dbusgen",
		gofmt:   true,
	}
	for _, opt := range opts {
		opt(p)
	}
	if !identRegexp.MatchString(p.pkgName) {
		return errors.New("package name is not valid")
	}
	if len(ifaces) == 0 {
		return errors.New("no interfaces given")
	}

	p.sortAll(ifaces)
	p.writeHeader(p.pkgName, ifaces)
	p.writeInterfaceFuncs(ifaces)
	if p.ifacesHaveSignals(ifaces) {
		p.writeSignalFuncs(ifaces)
	}
	for _, iface := range ifaces {
		p.writeInterface(iface)
		p.writeMethods(iface)
		p.writeProperties(iface)
		p.writeSignals(iface)
	}

	b, err := p.bytes()
	if err != nil {
		return err
	}
	if p.gofmt {
		b, err = format.Source(b)
		if err != nil {
			return fmt.Errorf("parse error: %s", err)
		}
	}
	_, err = out.Write(b)
	return err
}

// sortAll sorts all entities to provide the same output each run.
func (p *printer) sortAll(ifaces []*token.Interface) {
	sort.Slice(ifaces, func(i, j int) bool {
		return ifaces[i].Name < ifaces[j].Name
	})
	for _, iface := range ifaces {
		sort.Slice(iface.Methods, func(i, j int) bool {
			return iface.Methods[i].Name < iface.Methods[j].Name
		})
		sort.Slice(iface.Properties, func(i, j int) bool {
			return iface.Properties[i].Name < iface.Properties[j].Name
		})
		sort.Slice(iface.Signals, func(i, j int) bool {
			return iface.Signals[i].Name < iface.Signals[j].Name
		})
	}
}

func (p *printer) writeHeader(pkgName string, ifaces []*token.Interface) {
	p.writeln("// Generated by dbus-codegen-go, don't edit!")
	p.writeln("//")
	for i, iface := range ifaces {
		if i != 0 {
			p.writeln("//")
		}
		p.writeln("// ", iface.Name)
		if len(iface.Methods) != 0 {
			p.writeln("//   Methods")
			for _, method := range iface.Methods {
				p.writeln("//     ", method.Name)
			}
		}
		if len(iface.Properties) != 0 {
			p.writeln("//   Properties")
			for _, prop := range iface.Properties {
				p.writeln("//     ", prop.Name)
			}
		}
		if len(iface.Signals) != 0 {
			p.writeln("//   Signals")
			for _, sig := range iface.Signals {
				p.writeln("//     ", sig.Name)
			}
		}
	}
	p.writef(`
package %s

import (
	"log"

	"github.com/godbus/dbus"
)

const (
	methodPropertyGet = "org.freedesktop.DBus.Properties.Get"
	methodPropertySet = "org.freedesktop.DBus.Properties.Set"
)
`, pkgName)
}

func (p *printer) writeAnnotations(annotations []*token.Annotation) {
	for _, annotation := range annotations {
		p.writef("// @annotation %s = %s\n", annotation.Name, annotation.Value)
	}
}

func (p *printer) writeInterface(iface *token.Interface) {
	p.writef("// %s is %s interface name.\n", p.ifaceNameConst(iface), iface.Name)
	p.writef("const %s = %q\n", p.ifaceNameConst(iface), iface.Name)
	p.writef(`// %s creates and allocates %s.
func %s(object dbus.BusObject) *%s {
	return &%s{object}
}
`,
		p.ifaceNewType(iface), iface.Name,
		p.ifaceNewType(iface), p.ifaceType(iface),
		p.ifaceType(iface),
	)
	p.writef("// %s implements %s DBus interface.\n", p.ifaceType(iface), iface.Name)
	p.writeAnnotations(iface.Annotations)
	p.writef(`type %s struct {
	object dbus.BusObject
}

func (o *%s) iface() string {
	return %s
}
`,
		p.ifaceType(iface),
		p.ifaceType(iface), p.ifaceNameConst(iface),
	)
}

func (p *printer) writeMethods(iface *token.Interface) {
	for _, method := range iface.Methods {
		p.writef("// %s calls %s.%s method.\n", p.methodType(method), iface.Name, method.Name)
		p.writeAnnotations(method.Annotations)
		p.writef(`func (o *%s) %s(%s) (%serr error) {
	err = o.object.Call(%s + "." + "%s", 0, %s).Store(%s)
	return
}
`,
			p.ifaceType(iface), p.methodType(method), p.joinArgs(method.In, ',', "in", false),
			p.joinArgs(method.Out, ',', "out", false),
			p.ifaceNameConst(iface), method.Name, p.joinArgNames(method.In), p.joinStoreArgs(method.Out),
		)
	}
}

func (p *printer) writeProperties(iface *token.Interface) {
	for i, prop := range iface.Properties {
		if prop.Read && !p.ifaceHasMethod(iface, p.propGetType(prop)) {
			p.writef("// %s gets %s.%s property.\n", p.propGetType(prop), iface.Name, prop.Name)
			p.writeAnnotations(prop.Annotations)
			p.writef(`func (o *%s) %s() (%s %s, err error) {
	err = o.object.Call(methodPropertyGet, 0, %s, "%s").Store(&%s)
	return
}
`,
				p.ifaceType(iface), p.propGetType(prop), p.argName(prop.Arg, "v", i, false), prop.Arg.Type,
				p.ifaceNameConst(iface), prop.Name, p.argName(prop.Arg, "v", i, false),
			)
		}
		if prop.Write && !p.ifaceHasMethod(iface, p.propSetType(prop)) {
			p.writef("// %s sets %s.%s property.\n", p.propSetType(prop), iface.Name, prop.Name)
			p.writeAnnotations(prop.Annotations)
			p.writef(`func (o *%s) %s(%s %s) error {
	return o.object.Call(methodPropertySet, 0, %s, "%s", %s).Store()
}
`,
				p.ifaceType(iface), p.propSetType(prop), p.argName(prop.Arg, "v", 0, false), prop.Arg.Type,
				p.ifaceNameConst(iface), prop.Name, p.argName(prop.Arg, "v", 0, false),
			)
		}
	}
}

func (p *printer) writeSignals(iface *token.Interface) {
	for _, sig := range iface.Signals {
		p.writef("// %s represents %s.%s signal.\n", p.signalType(iface, sig), iface.Name, sig.Name)
		p.writeAnnotations(sig.Annotations)
		p.writef(`type %s struct {
	sender string
	path   dbus.ObjectPath
	Body   %s
}

// %s is a body container. 
type %s struct {
	%s
}

// Name returns the signal's name.
func (s *%s) Name() string {
	return "%s"
}

// Interface returns the signal's interface.
func (s *%s) Interface() string {
	return %s
}

// Sender returns the signal's sender unique name.
func (s *%s) Sender() string {
	return s.sender
}

// Path returns path that emitted the signal. 
func (s *%s) Path() dbus.ObjectPath {
	return s.path
}
`,
			p.signalType(iface, sig), p.signalBodyType(iface, sig),
			p.signalBodyType(iface, sig),
			p.signalBodyType(iface, sig), p.joinArgs(sig.Args, ';', "v", true),
			p.signalType(iface, sig), sig.Name,
			p.signalType(iface, sig), p.ifaceNameConst(iface),
			p.signalType(iface, sig),
			p.signalType(iface, sig),
		)
	}
}

func (p *printer) writeSignalFuncs(ifaces []*token.Interface) {
	p.writef(`// Signal is a common interface for all signals.
type Signal interface {
	Name() string
	Interface() string
	Sender() string
	Path() dbus.ObjectPath
}
`)
	p.writef(`// LookupSignal converts the given raw DBus signal into typed one or returns nil.
func LookupSignal(signal *dbus.Signal) Signal {
	switch signal.Name {
`)
	for _, iface := range ifaces {
		for _, sig := range iface.Signals {
			p.writef(`	case %s + "." + "%s":
`, p.ifaceNameConst(iface), sig.Name)
			for i, arg := range sig.Args {
				p.writef("		v%d, ok := signal.Body[%d].(%s)\n", i, i, arg.Type)
				p.writef(`		if !ok {
			log.Printf("[dbusgen] %s is %%T, not %s", signal.Body[%d])
		}
`,
					p.argName(arg, "v", i, true), arg.Type, i)
			}
			p.writef(`		return &%s{
			sender: signal.Sender,
			path:   signal.Path,
			Body:   %s{
`, p.signalType(iface, sig), p.signalBodyType(iface, sig),
			)
			for i, arg := range sig.Args {
				p.writef("				%s: v%d,\n", p.argName(arg, "v", i, true), i)
			}
			p.writeln("			},")
			p.writeln("		}")
		}
	}
	p.writef(`	default:
		return nil
	}
}
`)
	p.writef(`// AddMatchRule returns AddMatch rule for the given signal. 
func AddMatchRule(sig Signal) string {
	return "type='signal',interface='" + sig.Interface() + "',member='" + sig.Name() + "'"
}
`)
}

func (p *printer) writeInterfaceFuncs(ifaces []*token.Interface) {
	p.writef(`// Interface is a DBus interface implementation.
type Interface interface {
	iface() string
}

// LookupInterface returns an interface for the named object.
func LookupInterface(object dbus.BusObject, iface string) Interface {
	switch iface {
`)
	for _, iface := range ifaces {
		p.writef(`case %s:
	return New%s(object)
`, p.ifaceNameConst(iface), p.ifaceType(iface))
	}
	p.writef(`	default:
		return nil
	}
}
`)
}

func isKeyword(s string) bool {
	// TODO: validate it doesn't match imported package names
	return gotoken.Lookup(s).IsKeyword()
}

var ifaceRegexp = regexp.MustCompile(`\.[a-zA-Z0-9]`)

func (p *printer) ifaceType(iface *token.Interface) string {
	name := iface.Name
	for _, prefix := range p.prefixes {
		if prefix[len(prefix)-1] == '.' {
			prefix = prefix[:len(prefix)-1]
		}
		if i := strings.Index(name, prefix); i != -1 {
			name = name[i+len(prefix)+1:]
			break
		}
	}
	name = strings.Title(name)
	if isKeyword(name) {
		return name
	}
	return ifaceRegexp.ReplaceAllStringFunc(name, func(s string) string {
		return "_" + strings.ToUpper(s[1:])
	})
}

func (p *printer) ifaceNewType(iface *token.Interface) string {
	return "New" + p.ifaceType(iface)
}

func (p *printer) ifaceNameConst(iface *token.Interface) string {
	return "Interface" + p.ifaceType(iface)
}

func (p *printer) ifaceHasMethod(iface *token.Interface, name string) bool {
	for _, method := range iface.Methods {
		if method.Name == name {
			return true
		}
	}
	return false
}

func (p *printer) ifacesHaveSignals(ifaces []*token.Interface) bool {
	for _, iface := range ifaces {
		if len(iface.Signals) != 0 {
			return true
		}
	}
	return false
}

func (p *printer) methodType(method *token.Method) string {
	return strings.Title(method.Name)
}

func (p *printer) propType(prop *token.Property) string {
	return strings.Title(prop.Name)
}

func (p *printer) propGetType(prop *token.Property) string {
	return "Get" + p.propType(prop)
}

func (p *printer) propSetType(prop *token.Property) string {
	return "Set" + p.propType(prop)
}

func (p *printer) signalType(iface *token.Interface, signal *token.Signal) string {
	return p.ifaceType(iface) + "_" + strings.Title(signal.Name) + "Signal"
}

func (p *printer) signalBodyType(iface *token.Interface, signal *token.Signal) string {
	return p.signalType(iface, signal) + "Body"
}

var varRegexp = regexp.MustCompile("_+[a-zA-Z0-9]")

func (p *printer) argName(arg *token.Arg, prefix string, i int, export bool) string {
	name := arg.Name
	if name == "" {
		name = prefix + strconv.Itoa(i)
	} else {
		name = strings.ToLower(name[:1]) +
			varRegexp.ReplaceAllStringFunc(name[1:], func(s string) string {
				return strings.Title(strings.TrimLeft(s, "_"))
			})
	}
	if export {
		name = strings.Title(name)
	}
	if isKeyword(name) {
		return prefix + strings.Title(name)
	}
	return name
}

func (p *printer) joinStoreArgs(args []*token.Arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteByte('&')
		buf.WriteString(p.argName(args[i], "out", i, false))
	}
	return buf.String()
}

func (p *printer) joinArgs(args []*token.Arg, separator byte, suffix string, export bool) string {
	var buf strings.Builder
	for i := range args {
		buf.WriteString(p.argName(args[i], suffix, i, export))
		buf.WriteByte(' ')
		buf.WriteString(args[i].Type)
		buf.WriteByte(separator)
	}
	return buf.String()
}

func (p *printer) joinArgNames(args []*token.Arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteString(p.argName(args[i], "in", i, false))
	}
	return buf.String()
}
