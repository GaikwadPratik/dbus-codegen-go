package printer

import (
	"errors"
	"go/format"
	"io"
	"regexp"
	"sort"
	"strings"

	"github.com/amenzhinsky/godbus-codegen/token"
)

var identRegexp = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]*$")

type PrintOption func(p *printer)

type printer struct {
	pkgName  string
	prefixes []string
}

func WithPackageName(name string) PrintOption {
	return func(p *printer) {
		p.pkgName = name
	}
}

func Print(out io.Writer, ifaces []*token.Interface, opts ...PrintOption) error {
	p := &printer{
		pkgName: "dbusgen",
	}
	for _, opt := range opts {
		opt(p)
	}
	if !identRegexp.MatchString(p.pkgName) {
		return errors.New("package name is not valid")
	}
	if len(ifaces) == 0 {
		return errors.New("no interfaces given")
	}

	buf := newBuffer()

	sortAll(ifaces)
	writeHeader(buf, p.pkgName, ifaces)
	writeInterfaceLookup(buf, ifaces)
	if haveSignals(ifaces) {
		writeSignalLookup(buf, ifaces)
	}
	for _, iface := range ifaces {
		writeInterface(buf, iface)
		writeMethods(buf, iface)
		writeProperties(buf, iface)
		writeSignals(buf, iface)
	}

	//fmt.Println(string(buf.bytes()))

	// gofmt code
	b, err := format.Source(buf.bytes())
	if err != nil {
		return err
	}
	_, err = out.Write(b)
	return err
}

func haveSignals(ifaces []*token.Interface) bool {
	for _, iface := range ifaces {
		if len(iface.Signals) != 0 {
			return true
		}
	}
	return false
}

// sortAll sorts all entities to provide the same output each run.
func sortAll(ifaces []*token.Interface) {
	sort.Slice(ifaces, func(i, j int) bool {
		return ifaces[i].Name < ifaces[j].Name
	})
	for _, iface := range ifaces {
		sort.Slice(iface.Methods, func(i, j int) bool {
			return iface.Methods[i].Name < iface.Methods[j].Name
		})
		sort.Slice(iface.Properties, func(i, j int) bool {
			return iface.Properties[i].Name < iface.Properties[j].Name
		})
		sort.Slice(iface.Signals, func(i, j int) bool {
			return iface.Signals[i].Name < iface.Signals[j].Name
		})
	}
}

func writeHeader(buf *buffer, pkgName string, ifaces []*token.Interface) {
	buf.writeln("// Generated by dbusgen, don't edit!")
	buf.writeln("//")
	for i, iface := range ifaces {
		if i != 0 {
			buf.writeln("//")
		}
		buf.writeln("// ", iface.Name)
		if len(iface.Methods) != 0 {
			buf.writeln("//   Methods")
			for _, method := range iface.Methods {
				buf.writeln("//     ", method.Name)
			}
		}
		if len(iface.Properties) != 0 {
			buf.writeln("//   Properties")
			for _, prop := range iface.Properties {
				buf.writeln("//     ", prop.Name)
			}
		}
		if len(iface.Signals) != 0 {
			buf.writeln("//   Signals")
			for _, sig := range iface.Signals {
				buf.writeln("//     ", sig.Name)
			}
		}
	}
	buf.writeln("package ", pkgName)
	buf.writeln(`import "github.com/godbus/dbus"`)
}

func writeInterface(buf *buffer, iface *token.Interface) {
	buf.writef(`// %s returns %s DBus interface implementation.
func New%s(conn *dbus.Conn, dest string, path dbus.ObjectPath) *%s {
	return &%s{conn.Object(dest, path)}
}
`,
		iface.Type, iface.Name,
		iface.Type, iface.Type,
		iface.Type,
	)
	buf.writef(`// %s implements %s DBus interface.
type %s struct {
	object dbus.BusObject
}
`,
		iface.Type, iface.Name,
		iface.Type,
	)

	buf.writef(`func(o *%s) obj() dbus.BusObject {
	return o.object
}
`, iface.Type)
}

func writeMethods(buf *buffer, iface *token.Interface) {
	for _, method := range iface.Methods {
		buf.writef(`// %s calls %s.%s method.
func(o *%s) %s(%s) (%serr error) {
	err = o.object.Call("%s", 0, %s).Store(%s)
	return
}
`,
			iface.Type, iface.Name, method.Name,
			iface.Type, method.Type, joinArgs(method.In, ','), joinArgs(method.Out, ','),
			iface.Name+"."+method.Type, joinArgNames(method.In), joinStoreArgs(method.Out),
		)
	}
}

func writeProperties(buf *buffer, iface *token.Interface) {
	for _, prop := range iface.Properties {
		if prop.Read {
			buf.writef(`// %s gets %s.%s property.
func(o *%s) %s() (%s %s, err error) {
	err = o.object.Call("org.freedesktop.DBus.Properties.Get", 0, "%s", "%s").Store(&%s)
	return
}
`,
				prop.Type, iface.Name, prop.Name,
				iface.Type, prop.Type, prop.Arg.Name, prop.Arg.Type,
				iface.Name, prop.Name, prop.Arg.Name,
			)
		}
		if prop.Write {
			// TODO
		}
	}
}

func writeSignals(buf *buffer, iface *token.Interface) {
	for _, sig := range iface.Signals {
		buf.writef(`// %s represents %s.%s signal.
type %s struct {
	sender string
	path   dbus.ObjectPath
	body   %sBody
}

type %sBody struct {
	%s
}

// Name returns the signal's name.
func (s *%s) Name() string {
	return "%s"
}

// Interface returns the signal's interface.
func (s *%s) Interface() string {
	return "%s"
}

// Sender returns the signal's sender unique name.
func (s *%s) Sender() string {
	return s.sender
}

// Path returns path that emitted the signal. 
func (s *%s) Path() dbus.ObjectPath {
	return s.path
}

// Body returns the signals' payload.
func (s *%s) Body() %sBody {
	return s.body
}
`,
			sig.Type, iface.Name, sig.Name,
			sig.Type, sig.Type, sig.Type, joinArgs(sig.Args, ';'),
			sig.Type, sig.Name, sig.Type, iface.Name, sig.Type, sig.Type,
			sig.Type, sig.Type,
		)
	}
}

func writeSignalLookup(buf *buffer, ifaces []*token.Interface) {
	buf.writef(`// Signal is a common interface for all signals.
type Signal interface {
	Name() string
	Interface() string
	Sender() string
	Path() dbus.ObjectPath
}
`)
	buf.writef(`// LookupSignal converts the given raw DBus signal into typed one or returns nil.
func LookupSignal(signal *dbus.Signal) Signal {
	switch signal.Name {
`)
	for _, iface := range ifaces {
		for _, sig := range iface.Signals {
			buf.writef(`	case "%s.%s":
		return &%s{
			sender: signal.Sender,
			path:   signal.Path,
			body:   %sBody{
`, iface.Name, sig.Name, sig.Type, sig.Type)
			for i, arg := range sig.Args {
				buf.writef("				%s: signal.Body[%d].(%s),\n", arg.Name, i, arg.Type)
			}
			buf.writeln("			},")
			buf.writeln("		}")
		}
	}
	buf.writef(`	default:
		return nil
	}
}
`)
}

func writeInterfaceLookup(buf *buffer, ifaces []*token.Interface) {
	buf.writef(`// Interface is a DBus interface implementation.
type Interface interface {
	obj() dbus.BusObject
}
`)

	buf.writef(`// LookupInterface returns an interface for the named object.
func LookupInterface(conn *dbus.Conn, dest string, path dbus.ObjectPath, iface string) Interface {
	switch iface {
`)
	for _, iface := range ifaces {
		buf.writef(`case "%s":
	return New%s(conn, dest, path)
`, iface.Name, iface.Type)
	}
	buf.writef(`	default:
		return nil
	}
}
`)
}

func joinStoreArgs(args []*token.Arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteByte('&')
		buf.WriteString(args[i].Name)
	}
	return buf.String()
}

func joinArgs(args []*token.Arg, separator byte) string {
	var buf strings.Builder
	for i := range args {
		buf.WriteString(args[i].Name)
		buf.WriteByte(' ')
		buf.WriteString(args[i].Type)
		buf.WriteByte(separator)
	}
	return buf.String()
}

func joinArgNames(args []*token.Arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteString(args[i].Name)
	}
	return buf.String()
}
