package printer

import (
	"errors"
	"fmt"
	"go/format"
	gotoken "go/token"
	"io"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/amenzhinsky/dbus-codegen-go/token"
)

// PrintOption is a Print configuration option.
type PrintOption func(p *printer)

type printer struct {
	pkgName string
	gofmt   bool
}

// WithPackageName overrides the package name of generated code.
func WithPackageName(name string) PrintOption {
	return func(p *printer) {
		p.pkgName = name
	}
}

// WithGofmt gofmts generated code, enabled by default.
//
// Not recommended to disable it, only for debugging the output,
// because gofmt works as a validation step as well.
func WithGofmt(enable bool) PrintOption {
	return func(p *printer) {
		p.gofmt = enable
	}
}

var identRegexp = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]*$")

// Print generates code for the provided interfaces and writes it to out.
func Print(out io.Writer, ifaces []*token.Interface, opts ...PrintOption) error {
	p := &printer{
		pkgName: "dbusgen",
		gofmt:   true,
	}
	for _, opt := range opts {
		opt(p)
	}
	if !identRegexp.MatchString(p.pkgName) {
		return errors.New("package name is not valid")
	}
	if len(ifaces) == 0 {
		return errors.New("no interfaces given")
	}

	buf := newBuffer()

	sortAll(ifaces)
	writeHeader(buf, p.pkgName, ifaces)
	writeInterfaceFuncs(buf, ifaces)
	if ifacesHaveSignals(ifaces) {
		writeSignalFuncs(buf, ifaces)
	}
	for _, iface := range ifaces {
		writeInterface(buf, iface)
		writeMethods(buf, iface)
		writeProperties(buf, iface)
		writeSignals(buf, iface)
	}

	b, err := buf.bytes()
	if err != nil {
		return err
	}
	if p.gofmt {
		b, err = format.Source(b)
		if err != nil {
			return fmt.Errorf("parse error: %s", err)
		}
	}
	_, err = out.Write(b)
	return err
}

// sortAll sorts all entities to provide the same output each run.
func sortAll(ifaces []*token.Interface) {
	sort.Slice(ifaces, func(i, j int) bool {
		return ifaces[i].Name < ifaces[j].Name
	})
	for _, iface := range ifaces {
		sort.Slice(iface.Methods, func(i, j int) bool {
			return iface.Methods[i].Name < iface.Methods[j].Name
		})
		sort.Slice(iface.Properties, func(i, j int) bool {
			return iface.Properties[i].Name < iface.Properties[j].Name
		})
		sort.Slice(iface.Signals, func(i, j int) bool {
			return iface.Signals[i].Name < iface.Signals[j].Name
		})
	}
}

func writeHeader(buf *buffer, pkgName string, ifaces []*token.Interface) {
	buf.writeln("// Generated by dbusgen, don't edit!")
	buf.writeln("//")
	for i, iface := range ifaces {
		if i != 0 {
			buf.writeln("//")
		}
		buf.writeln("// ", iface.Name)
		if len(iface.Methods) != 0 {
			buf.writeln("//   Methods")
			for _, method := range iface.Methods {
				buf.writeln("//     ", method.Name)
			}
		}
		if len(iface.Properties) != 0 {
			buf.writeln("//   Properties")
			for _, prop := range iface.Properties {
				buf.writeln("//     ", prop.Name)
			}
		}
		if len(iface.Signals) != 0 {
			buf.writeln("//   Signals")
			for _, sig := range iface.Signals {
				buf.writeln("//     ", sig.Name)
			}
		}
	}
	buf.writef(`
package %s

import "github.com/godbus/dbus"

const (
	methodPropertyGet = "org.freedesktop.DBus.Properties.Get"
	methodPropertySet = "org.freedesktop.DBus.Properties.Set"
)
`, pkgName)
}

func writeInterface(buf *buffer, iface *token.Interface) {
	buf.writef(`// %s returns %s DBus interface implementation.
func %s(object dbus.BusObject) *%s {
	return &%s{object}
}
`,
		ifaceNewType(iface), iface.Name,
		ifaceNewType(iface), ifaceType(iface),
		ifaceType(iface),
	)
	buf.writef(`// %s implements %s DBus interface.
type %s struct {
	object dbus.BusObject
}

func (o *%s) iface() string {
	return %s
}
`,
		ifaceType(iface), iface.Name,
		ifaceType(iface),
		ifaceType(iface), ifaceNameConst(iface),
	)
}

func writeMethods(buf *buffer, iface *token.Interface) {
	for _, method := range iface.Methods {
		buf.writef(`// %s calls %s.%s method.
func (o *%s) %s(%s) (%serr error) {
	err = o.object.Call(%s + "." + "%s", 0, %s).Store(%s)
	return
}
`,
			methodType(method), iface.Name, method.Name,
			ifaceType(iface), methodType(method), joinArgs(method.In, ',', "in", false),
			joinArgs(method.Out, ',', "out", false),
			ifaceNameConst(iface), method.Name, joinArgNames(method.In), joinStoreArgs(method.Out),
		)
	}
}

func writeProperties(buf *buffer, iface *token.Interface) {
	for i, prop := range iface.Properties {
		if prop.Read && !ifaceHasMethod(iface, propGetType(prop)) {
			buf.writef(`// %s gets %s.%s property.
func (o *%s) %s() (%s %s, err error) {
	err = o.object.Call(methodPropertyGet, 0, %s, "%s").Store(&%s)
	return
}
`,
				propGetType(prop), iface.Name, prop.Name,
				ifaceType(iface), propGetType(prop), argName(prop.Arg, "v", i, false), prop.Arg.Type,
				ifaceNameConst(iface), prop.Name, argName(prop.Arg, "v", i, false),
			)
		}
		if prop.Write && !ifaceHasMethod(iface, propSetType(prop)) {
			buf.writef(`// %s sets %s.%s property.
func (o *%s) %s(%s %s) error {
	return o.object.Call(methodPropertySet, 0, %s, "%s", %s).Store()
}
`,
				propSetType(prop), iface.Name, prop.Name,
				ifaceType(iface), propSetType(prop), argName(prop.Arg, "v", 0, false), prop.Arg.Type,
				ifaceNameConst(iface), prop.Name, argName(prop.Arg, "v", 0, false),
			)
		}
	}
}

func writeSignals(buf *buffer, iface *token.Interface) {
	for _, sig := range iface.Signals {
		buf.writef(`// %s represents %s.%s signal.
type %s struct {
	sender string
	path   dbus.ObjectPath
	body   %s
}

// %s is a body container. 
type %s struct {
	%s
}

// Name returns the signal's name.
func (s *%s) Name() string {
	return "%s"
}

// Interface returns the signal's interface.
func (s *%s) Interface() string {
	return "%s"
}

// Sender returns the signal's sender unique name.
func (s *%s) Sender() string {
	return s.sender
}

// Path returns path that emitted the signal. 
func (s *%s) Path() dbus.ObjectPath {
	return s.path
}

// Body returns the signals' payload.
func (s *%s) Body() %s {
	return s.body
}
`,
			signalType(iface, sig), iface.Name, sig.Name,
			signalType(iface, sig), signalBodyType(iface, sig),
			signalBodyType(iface, sig),
			signalBodyType(iface, sig), joinArgs(sig.Args, ';', "v", true),
			signalType(iface, sig), sig.Name,
			signalType(iface, sig), iface.Name,
			signalType(iface, sig),
			signalType(iface, sig),
			signalType(iface, sig), signalBodyType(iface, sig),
		)
	}
}

func writeSignalFuncs(buf *buffer, ifaces []*token.Interface) {
	buf.writef(`// Signal is a common interface for all signals.
type Signal interface {
	Name() string
	Interface() string
	Sender() string
	Path() dbus.ObjectPath
}
`)
	buf.writef(`// LookupSignal converts the given raw DBus signal into typed one or returns nil.
func LookupSignal(signal *dbus.Signal) Signal {
	switch signal.Name {
`)
	for _, iface := range ifaces {
		for _, sig := range iface.Signals {
			buf.writef(`	case %s + "." + "%s":
		return &%s{
			sender: signal.Sender,
			path:   signal.Path,
			body:   %s{
`,
				ifaceNameConst(iface), sig.Name,
				signalType(iface, sig),
				signalBodyType(iface, sig),
			)
			for i, arg := range sig.Args {
				buf.writef("				%s: signal.Body[%d].(%s),\n", argName(arg, "v", i, true), i, arg.Type)
			}
			buf.writeln("			},")
			buf.writeln("		}")
		}
	}
	buf.writef(`	default:
		return nil
	}
}
`)
}

func writeInterfaceFuncs(buf *buffer, ifaces []*token.Interface) {
	buf.writeln("// interface names")
	buf.writeln("const (")
	for _, iface := range ifaces {
		buf.writef("	%s = %q\n", ifaceNameConst(iface), iface.Name)
	}
	buf.writeln(")")

	buf.writef(`// Interface is a DBus interface implementation.
type Interface interface {
	iface() string
}

// LookupInterface returns an interface for the named object.
func LookupInterface(object dbus.BusObject, iface string) Interface {
	switch iface {
`)
	for _, iface := range ifaces {
		buf.writef(`case %s:
	return New%s(object)
`, ifaceNameConst(iface), ifaceType(iface))
	}
	buf.writef(`	default:
		return nil
	}
}
`)
}

func isKeyword(s string) bool {
	// TODO: validate it doesn't match imported package names
	return gotoken.Lookup(s).IsKeyword()
}

var ifaceRegexp = regexp.MustCompile("\\.[a-zA-Z0-9]")

func ifaceType(iface *token.Interface) string {
	name := strings.Title(iface.Name)
	if isKeyword(name) {
		return name
	}
	return ifaceRegexp.ReplaceAllStringFunc(name, func(s string) string {
		return "_" + strings.ToUpper(s[1:])
	})
}

func ifaceNewType(iface *token.Interface) string {
	return "New" + ifaceType(iface)
}

func ifaceNameConst(iface *token.Interface) string {
	return "Interface" + ifaceType(iface)
}

func ifaceHasMethod(iface *token.Interface, name string) bool {
	for _, method := range iface.Methods {
		if method.Name == name {
			return true
		}
	}
	return false
}

func ifacesHaveSignals(ifaces []*token.Interface) bool {
	for _, iface := range ifaces {
		if len(iface.Signals) != 0 {
			return true
		}
	}
	return false
}

func methodType(method *token.Method) string {
	return strings.Title(method.Name)
}

func propType(prop *token.Property) string {
	return strings.Title(prop.Name)
}

func propGetType(prop *token.Property) string {
	return "Get" + propType(prop)
}

func propSetType(prop *token.Property) string {
	return "Set" + propType(prop)
}

func signalType(iface *token.Interface, signal *token.Signal) string {
	return ifaceType(iface) + "_" + strings.Title(signal.Name) + "Signal"
}

func signalBodyType(iface *token.Interface, signal *token.Signal) string {
	return signalType(iface, signal) + "Body"
}

var varRegexp = regexp.MustCompile("_+[a-zA-Z0-9]")

func argName(arg *token.Arg, prefix string, i int, export bool) string {
	name := arg.Name
	if name == "" {
		name = prefix + strconv.Itoa(i)
	} else {
		name = strings.ToLower(name[:1]) +
			varRegexp.ReplaceAllStringFunc(name[1:], func(s string) string {
				return strings.Title(strings.TrimLeft(s, "_"))
			})
	}
	if export {
		name = strings.Title(name)
	}
	if isKeyword(name) {
		return prefix + strings.Title(name)
	}
	return name
}

func joinStoreArgs(args []*token.Arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteByte('&')
		buf.WriteString(argName(args[i], "out", i, false))
	}
	return buf.String()
}

func joinArgs(args []*token.Arg, separator byte, suffix string, export bool) string {
	var buf strings.Builder
	for i := range args {
		buf.WriteString(argName(args[i], suffix, i, export))
		buf.WriteByte(' ')
		buf.WriteString(args[i].Type)
		buf.WriteByte(separator)
	}
	return buf.String()
}

func joinArgNames(args []*token.Arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteString(argName(args[i], "in", i, false))
	}
	return buf.String()
}
