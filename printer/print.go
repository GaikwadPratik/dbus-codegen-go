package printer

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"strings"

	"github.com/amenzhinsky/godbus-codegen/token"
)

type buffer struct {
	buf bytes.Buffer
}

func (b *buffer) writef(format string, v ...interface{}) (int, error) {
	return fmt.Fprintf(&b.buf, format, v...)
}

func (b *buffer) bytes() []byte {
	return b.buf.Bytes()
}

func Print(out io.Writer, packageName string, ifaces []*token.Interface) error {
	buf := &buffer{}
	buf.writef(`// generated by dbusgen, don't edit
package %s

import "github.com/godbus/dbus"

`, packageName)

	signals := map[string][]*token.Signal{}
	for _, iface := range ifaces {
		if err := writeIface(buf, iface, signals); err != nil {
			return err
		}
	}
	if len(signals) > 0 {
		if err := writeSignalFuncs(buf, signals); err != nil {
			return err
		}
	}

	// gofmt code
	b, err := format.Source(buf.bytes())
	if err != nil {
		return err
	}
	_, err = out.Write(b)
	return err
}

func writeIface(buf *buffer, iface *token.Interface, signals map[string][]*token.Signal) error {
	buf.writef(`// %s returns %s DBus interface implementation.
func New%s(conn *dbus.Conn, dest string, path dbus.ObjectPath) *%s {
	return &%s{conn.Object(dest, path)}
}

`, iface.Type, iface.Name, iface.Type, iface.Type, iface.Type)
	buf.writef(`// %s implements %s DBus interface.
type %s struct {
	object dbus.BusObject
}

`, iface.Type, iface.Name, iface.Type)

	for _, method := range iface.Methods {
		buf.writef(`// %s calls %s.%s method.
func(o *%s) %s(%s) (%serr error) {
	err = o.object.Call("%s", 0, %s).Store(%s)
	return
}

`, iface.Type, iface.Name, method.Name, iface.Type, method.Type,
			joinArgs(method.In, ','), joinArgs(method.Out, ','),
			iface.Name+"."+method.Type, joinArgNames(method.In), argsToStore(method.Out))
	}

	for _, prop := range iface.Properties {
		method := strings.Title(prop.Name)
		if prop.Read {
			buf.writef(`// %s gets %s.%s property.
func(o *%s) %s() (%s, error) {
	var v dbus.Variant
	if err := o.object.Call(
		"org.freedesktop.DBus.Properties.Get", 0, "%s", "%s",
	).Store(&v); err != nil {
		return %s, err
	}
	return v.Value().(%s), nil
}

`, method, iface.Name, prop.Name, iface.Type, method, prop.Return,
				iface.Name, prop.Name, prop.Default, prop.Return)
		}
	}

	if len(iface.Signals) > 0 {
		signals[iface.Name] = iface.Signals
	}
	for _, sig := range iface.Signals {
		buf.writef(`// %s represents %s.%s signal.
type %s struct {
	sender string
	path   dbus.ObjectPath

	%s
}

func (s *%s) Name() string {
	return "%s"
}

func (s *%s) Interface() string {
	return "%s"
}

func (s *%s) Sender() string {
	return s.sender
}

func (s *%s) Path() dbus.ObjectPath {
	return s.path
}
`, sig.Type, sig.Name, iface.Name, sig.Type, joinArgs(sig.Args, ';'),
			sig.Type, sig.Name, sig.Type, iface.Name, sig.Type, sig.Type)
	}
	return nil
}

func writeSignalFuncs(buf *buffer, signals map[string][]*token.Signal) error {
	buf.writef(`// Signal is a common interface for all signals.
type Signal interface {
	Name() string
	Interface() string
	Sender() string
	Path() dbus.ObjectPath
}

`)
	buf.writef(`// LookupSignal converts the given raw DBus signal into typed one.
func LookupSignal(signal *dbus.Signal) Signal {
	switch signal.Name {
`)
	for iface, sigs := range signals {
		for _, sig := range sigs {
			buf.writef(`	case "%s.%s":
		return &%s{
			sender: signal.Sender,
			path:   signal.Path,
`, iface, sig.Name, sig.Type)
			for i, arg := range sig.Args {
				buf.writef("			%s: signal.Body[%d].(%s),\n", arg.Name, i, arg.Type)
			}
			buf.writef(`		}
`)
		}
	}
	buf.writef(`	default:
		return nil
	}
}
`)
	return nil
}

func argsToStore(args []*token.Arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteByte('&')
		buf.WriteString(args[i].Name)
	}
	return buf.String()
}

func joinArgs(args []*token.Arg, separator byte) string {
	var buf strings.Builder
	for i := range args {
		buf.WriteString(args[i].Name)
		buf.WriteByte(' ')
		buf.WriteString(args[i].Type)
		buf.WriteByte(separator)
	}
	return buf.String()
}

func joinArgNames(args []*token.Arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteString(args[i].Name)
	}
	return buf.String()
}
