package dbusgen

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"go/format"
	"regexp"
	"strings"

	"github.com/godbus/dbus/introspect"
)

type GeneratorOption func(g *Generator)

func WithPackageName(name string) GeneratorOption {
	if name == "" {
		panic("name is empty")
	}
	return func(g *Generator) {
		g.pkgName = name
	}
}

type Generator struct {
	pkgName string
}

func New(opts ...GeneratorOption) (*Generator, error) {
	g := &Generator{
		pkgName: "dbusgen",
	}
	for _, opt := range opts {
		opt(g)
	}
	return g, nil
}

func (g *Generator) Generate(b []byte, ifaces ...string) ([]byte, error) {
	var node introspect.Node
	if err := xml.Unmarshal(b, &node); err != nil {
		return nil, err
	}
	list := make([]introspect.Interface, 0, len(node.Interfaces))
	for _, iface := range node.Interfaces {
		if len(ifaces) > 0 && !includes(ifaces, iface.Name) {
			continue
		}
		list = append(list, iface)
	}
	return g.gen(list...)
}

func includes(ss []string, s string) bool {
	for i := 0; i < len(ss); i++ {
		if ss[i] == s {
			return true
		}
	}
	return false
}

func (g *Generator) gen(ifaces ...introspect.Interface) ([]byte, error) {
	buf := &buffer{}
	buf.WriteStringf(`// generated by dbusgen, don't edit
package %s

import "github.com/godbus/dbus"

`, g.pkgName)

	for _, iface := range ifaces {
		g.iface(buf, iface)
	}
	return format.Source(buf.Bytes())
}

func (g *Generator) iface(buf *buffer, iface introspect.Interface) error {
	typ := nameToGoType(iface.Name, true)
	buf.WriteStringf(`// %s returns %s DBus interface implementation.
func New%s(conn *dbus.Conn, dest string, path dbus.ObjectPath) *%s {
	return &%s{conn.Object(dest, path)}
}

`, typ, iface.Name, typ, typ, typ)
	buf.WriteStringf(`// %s implements %s DBus interface.
type %s struct {
	object dbus.BusObject
}

`, typ, iface.Name, typ)

	for _, method := range iface.Methods {
		name := strings.Title(method.Name)
		in, out := argsToGoInOut(method.Args)
		buf.WriteStringf(`// %s calls %s.%s method.
func(o *%s) %s(%s) (%serr error) {
	err = o.object.Call("%s", 0).Store(%s)
	return
}

`, name, iface.Name, method.Name, typ, name,
			joinArgs(in, ','), joinArgs(out, ','),
			iface.Name+"."+method.Name, argsToStore(out))
	}

	for _, prop := range iface.Properties {
		method := strings.Title(prop.Name)
		if strings.Index(prop.Access, "read") >= 0 {
			retType := sigToGo(prop.Type, "")
			buf.WriteStringf(`// %s gets %s.%s property.
func(o *%s) %s() (%s, error) {
	var v dbus.Variant
	if err := o.object.Call(
		"org.freedesktop.DBus.Properties.Get", 0, "%s", "%s",
	).Store(&v); err != nil {
		return %s, err
	}
	return v.Value().(%s), nil
}

`, method, iface.Name, prop.Name, typ, method, retType,
				iface.Name, prop.Name, goDefaultValue(prop.Type), retType)
		}
	}

	for _, sig := range iface.Signals {
		name := typ + strings.Title(sig.Name) + "Signal"
		_, args := argsToGoInOut(sig.Args)
		buf.WriteStringf(`// %s represents %s.%s signal.
type %s struct {
	%s
}

`, name, sig.Name, iface.Name, name, joinArgs(args, ';'))
	}
	return nil
}

func goDefaultValue(sig string) string {
	switch sig[0] {
	case 'b':
		return "false"
	case 'y', 'n', 'q', 'i', 'u', 'x', 't', 'd', 'h':
		return "0"
	case 's', 'o':
		return `""`
	case 'v', 'a':
		return "nil"
	case 'g':
		return "dbus.Signature{}"
	case '(':
		panic("not implemented yet")
	default:
		panic("not supported signature: " + string(sig[0]))
	}
}

type buffer struct {
	bytes.Buffer
}

func (b *buffer) WriteStringf(format string, v ...interface{}) (int, error) {
	return fmt.Fprintf(b, format, v...)
}

func argsToStore(args []arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteByte('&')
		buf.WriteString(args[i].name)
	}
	return buf.String()
}

func joinArgs(args []arg, separator byte) string {
	var buf strings.Builder
	for i := range args {
		buf.WriteString(args[i].name)
		buf.WriteByte(' ')
		buf.WriteString(args[i].kind)
		buf.WriteByte(separator)
	}
	return buf.String()
}

var nameRegexp = regexp.MustCompile("(?:^|\\.|_)[a-zA-Z0-9]")

func nameToGoType(name string, export bool) string {
	if isKeyword(name) {
		if export {
			return strings.Title(name)
		}
		return "arg" + name
	}
	return nameRegexp.ReplaceAllStringFunc(name, func(sub string) string {
		if sub[0] == '.' || sub[0] == '_' {
			sub = sub[1:]
		} else if !export {
			return sub
		}
		return strings.ToUpper(sub)
	})
}

func argsToGoInOut(args []introspect.Arg) ([]arg, []arg) {
	var in, out []arg
	for i := range args {
		if args[i].Direction == "in" {
			in = append(in, newArg(args[i].Name, args[i].Type, "arg", len(in)))
		} else {
			out = append(out, newArg(args[i].Name, args[i].Type, "ret", len(out)))
		}
	}
	return in, out
}

func sigToGo(sig, join string) string {
	var r []string
	for i := 0; i < len(sig); {
		s, rlen := next(sig[i:])
		if rlen == 0 {
			break
		}
		i += rlen
		r = append(r, s)
	}
	return strings.Join(r, join)
}

func next(sig string) (string, int) {
	if len(sig) == 0 {
		return "", 0
	}
	switch sig[0] {
	case 'y':
		return "byte", 1
	case 'b':
		return "bool", 1
	case 'n':
		return "int16", 1
	case 'q':
		return "uint16", 1
	case 'i':
		return "int32", 1
	case 'u':
		return "uint32", 1
	case 'x':
		return "int64", 1
	case 't':
		return "uint64", 1
	case 'd':
		return "float64", 1
	case 'h':
		return "dbus.UnixFD", 1
	case 's':
		return "string", 1
	case 'o':
		return "dbus.ObjectPath", 1
	case 'v':
		return "interface{}", 1
	case 'g':
		return "dbus.Signature", 1
	case 'a':
		if sig[1] == '{' { // dictionary
			i := 4
			k, rlen := next(sig[2:])
			if rlen != 1 {
				panic("key is not a primitive")
			}
			v, rlen := next(sig[3:])
			if rlen == 0 {
				panic("value is not available")
			}
			i += rlen
			return "map[" + k + "]" + v, i
		}
		s, rlen := next(sig[1:])
		return "[]" + s, rlen + 1
	case '(':
		i := 1
		n := 1
		for i < len(sig) && n != 0 {
			if sig[i] == '(' {
				n++
			} else if sig[i] == ')' {
				n--
			}
			i++
		}
		return "struct {" + sigToGo(sig[1:i-1], ";") + "}", i
	default:
		panic("not supported signature: " + string(sig[0]))
	}
}
