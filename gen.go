package dbusgen

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"go/format"
	"strings"

	"github.com/godbus/dbus/introspect"
)

type GeneratorOption func(g *Generator)

func WithPackageName(name string) GeneratorOption {
	if name == "" {
		panic("name is empty")
	}
	return func(g *Generator) {
		g.pkgName = name
	}
}

type Generator struct {
	pkgName string
}

func New(opts ...GeneratorOption) (*Generator, error) {
	g := &Generator{
		pkgName: "dbusgen",
	}
	for _, opt := range opts {
		opt(g)
	}
	return g, nil
}

func (g *Generator) Generate(b []byte, ifaces ...string) ([]byte, error) {
	var node introspect.Node
	if err := xml.Unmarshal(b, &node); err != nil {
		return nil, err
	}
	list := make([]introspect.Interface, 0, len(node.Interfaces))
	for _, iface := range node.Interfaces {
		if len(ifaces) > 0 && !includes(ifaces, iface.Name) {
			continue
		}
		list = append(list, iface)
	}
	return g.gen(list...)
}

func includes(ss []string, s string) bool {
	for i := 0; i < len(ss); i++ {
		if ss[i] == s {
			return true
		}
	}
	return false
}

func (g *Generator) gen(ifaces ...introspect.Interface) ([]byte, error) {
	buf := &buffer{}
	buf.writef(`// generated by dbusgen, don't edit
package %s

import "github.com/godbus/dbus"

`, g.pkgName)

	var signals []*signal
	for _, iface := range ifaces {
		if err := g.iface(buf, iface, &signals); err != nil {
			return nil, err
		}
	}
	if err := g.signals(buf, signals); err != nil {
		return nil, err
	}
	return format.Source(buf.bytes())
}

func (g *Generator) iface(buf *buffer, iface introspect.Interface, signals *[]*signal) error {
	typ := newIfaceType(iface.Name)
	buf.writef(`// %s returns %s DBus interface implementation.
func New%s(conn *dbus.Conn, dest string, path dbus.ObjectPath) *%s {
	return &%s{conn.Object(dest, path)}
}

`, typ, iface.Name, typ, typ, typ)
	buf.writef(`// %s implements %s DBus interface.
type %s struct {
	object dbus.BusObject
}

`, typ, iface.Name, typ)

	for _, method := range iface.Methods {
		name := strings.Title(method.Name)
		in := argsToGoArgs(method.Args, "in", "arg", false)
		out := argsToGoArgs(method.Args, "out", "ret", false)
		buf.writef(`// %s calls %s.%s method.
func(o *%s) %s(%s) (%serr error) {
	err = o.object.Call("%s", 0).Store(%s)
	return
}

`, name, iface.Name, method.Name, typ, name,
			joinArgs(in, ','), joinArgs(out, ','),
			iface.Name+"."+method.Name, argsToStore(out))
	}

	for _, prop := range iface.Properties {
		method := strings.Title(prop.Name)
		if strings.Index(prop.Access, "read") >= 0 {
			retType := parseSignature(prop.Type)[0]
			buf.writef(`// %s gets %s.%s property.
func(o *%s) %s() (%s, error) {
	var v dbus.Variant
	if err := o.object.Call(
		"org.freedesktop.DBus.Properties.Get", 0, "%s", "%s",
	).Store(&v); err != nil {
		return %s, err
	}
	return v.Value().(%s), nil
}

`, method, iface.Name, prop.Name, typ, method, retType,
				iface.Name, prop.Name, signatureZeroValue(prop.Type), retType)
		}
	}

	for _, sig := range parseSignals(typ, iface.Name, iface.Signals) {
		*signals = append(*signals, sig)
		buf.writef(`// %s represents %s.%s signal.
type %s struct {
	sender string
	path   dbus.ObjectPath

	%s
}

func (s *%s) Name() string {
	return "%s"
}

func (s *%s) Interface() string {
	return "%s"
}

func (s *%s) Sender() string {
	return s.sender
}

func (s *%s) Path() dbus.ObjectPath {
	return s.path
}
`, sig.gtyp, sig.name, iface.Name, sig.gtyp, joinArgs(sig.args, ';'),
			sig.gtyp, sig.name, sig.gtyp, iface.Name, sig.gtyp, sig.gtyp)
	}
	return nil
}

func (g *Generator) signals(buf *buffer, signals []*signal) error {
	if len(signals) == 0 {
		return nil
	}
	buf.writef(`// Signal is a common interface for all signals.
type Signal interface {
	Name() string
	Interface() string
	Sender() string
	Path() dbus.ObjectPath
}

`)
	buf.writef(`// LookupSignal converts the given raw DBus signal into typed one.
func LookupSignal(signal dbus.Signal) Signal {
	switch signal.Name {
`)
	for _, sig := range signals {
		buf.writef(`	case "%s.%s":
		return &%s{
			sender: signal.Sender,
			path:   signal.Path,
`, sig.iface, sig.name, sig.gtyp)
		for i, arg := range sig.args {
			buf.writef("			%s: signal.Body[%d].(%s),\n", arg.name, i, arg.kind)
		}
		buf.writef(`		}
`)
	}
	buf.writef(`	default:
		return nil
	}
}
`)
	return nil
}

type buffer struct {
	buf bytes.Buffer
}

func (b *buffer) writef(format string, v ...interface{}) (int, error) {
	return fmt.Fprintf(&b.buf, format, v...)
}

func (b *buffer) bytes() []byte {
	return b.buf.Bytes()
}

func argsToStore(args []arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteByte('&')
		buf.WriteString(args[i].name)
	}
	return buf.String()
}

func joinArgs(args []arg, separator byte) string {
	var buf strings.Builder
	for i := range args {
		buf.WriteString(args[i].name)
		buf.WriteByte(' ')
		buf.WriteString(args[i].kind)
		buf.WriteByte(separator)
	}
	return buf.String()
}

func argsToGoArgs(args []introspect.Arg, direction, prefix string, export bool) []arg {
	out := make([]arg, 0, len(args))
	for i := range args {
		if direction != "" && args[i].Direction != direction {
			continue
		}
		out = append(out, parseArg(args[i].Name, args[i].Type, prefix, len(out), export))
	}
	return out
}
