package dbusgen

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"go/format"
	"regexp"
	"strings"

	"github.com/godbus/dbus/introspect"
)

type GeneratorOption func(g *Generator)

func WithPackageName(name string) GeneratorOption {
	if name == "" {
		panic("name is empty")
	}
	return func(g *Generator) {
		g.pkgName = name
	}
}

type Generator struct {
	pkgName string
}

func New(opts ...GeneratorOption) (*Generator, error) {
	g := &Generator{
		pkgName: "dbusgen",
	}
	for _, opt := range opts {
		opt(g)
	}
	return g, nil
}

func (g *Generator) Generate(b []byte, ifaces ...string) ([]byte, error) {
	var node introspect.Node
	if err := xml.Unmarshal(b, &node); err != nil {
		return nil, err
	}
	list := make([]introspect.Interface, 0, len(node.Interfaces))
	for _, iface := range node.Interfaces {
		if len(ifaces) > 0 && !includes(ifaces, iface.Name) {
			continue
		}
		list = append(list, iface)
	}
	return g.gen(list...)
}

func includes(ss []string, s string) bool {
	for i := 0; i < len(ss); i++ {
		if ss[i] == s {
			return true
		}
	}
	return false
}

func (g *Generator) gen(ifaces ...introspect.Interface) ([]byte, error) {
	buf := &buffer{}
	buf.WriteStringf(`// generated by dbusgen, don't edit
package %s

import "github.com/godbus/dbus"

`, g.pkgName)

	for _, iface := range ifaces {
		g.iface(buf, iface)
	}
	return format.Source(buf.Bytes())
}

func (g *Generator) iface(buf *buffer, iface introspect.Interface) error {
	typ := nameToGoType(iface.Name, true)
	buf.WriteStringf(`// %s returns %s DBus interface implementation.
func New%s(conn *dbus.Conn, dest string, path dbus.ObjectPath) *%s {
	return &%s{conn.Object(dest, path)}
}

`, typ, iface.Name, typ, typ, typ)
	buf.WriteStringf(`// %s implements %s DBus interface.
type %s struct {
	object dbus.BusObject
}

`, typ, iface.Name, typ)

	for _, method := range iface.Methods {
		name := strings.Title(method.Name)
		in, out := argsToGoInOut(method.Args)
		buf.WriteStringf(`// %s calls %s.%s method.
func(o *%s) %s(%s) (%serr error) {
	err = o.object.Call("%s", 0).Store(%s)
	return
}

`, name, iface.Name, method.Name, typ, name,
			joinArgs(in, ','), joinArgs(out, ','),
			iface.Name+"."+method.Name, argsToStore(out))
	}

	for _, prop := range iface.Properties {
		method := strings.Title(prop.Name)
		if strings.Index(prop.Access, "read") >= 0 {
			retType := newSig(prop.Type)[0]
			buf.WriteStringf(`// %s gets %s.%s property.
func(o *%s) %s() (%s, error) {
	var v dbus.Variant
	if err := o.object.Call(
		"org.freedesktop.DBus.Properties.Get", 0, "%s", "%s",
	).Store(&v); err != nil {
		return %s, err
	}
	return v.Value().(%s), nil
}

`, method, iface.Name, prop.Name, typ, method, retType,
				iface.Name, prop.Name, sigZeroValue(prop.Type), retType)
		}
	}

	for _, sig := range iface.Signals {
		name := typ + strings.Title(sig.Name) + "Signal"
		_, args := argsToGoInOut(sig.Args)
		buf.WriteStringf(`// %s represents %s.%s signal.
type %s struct {
	%s
}

`, name, sig.Name, iface.Name, name, joinArgs(args, ';'))
	}
	return nil
}

type buffer struct {
	bytes.Buffer
}

func (b *buffer) WriteStringf(format string, v ...interface{}) (int, error) {
	return fmt.Fprintf(b, format, v...)
}

func argsToStore(args []arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteByte('&')
		buf.WriteString(args[i].name)
	}
	return buf.String()
}

func joinArgs(args []arg, separator byte) string {
	var buf strings.Builder
	for i := range args {
		buf.WriteString(args[i].name)
		buf.WriteByte(' ')
		buf.WriteString(args[i].kind)
		buf.WriteByte(separator)
	}
	return buf.String()
}

var nameRegexp = regexp.MustCompile("(?:^|\\.|_)[a-zA-Z0-9]")

func nameToGoType(name string, export bool) string {
	if isKeyword(name) {
		if export {
			return strings.Title(name)
		}
		return "arg" + name
	}
	return nameRegexp.ReplaceAllStringFunc(name, func(sub string) string {
		if sub[0] == '.' || sub[0] == '_' {
			sub = sub[1:]
		} else if !export {
			return sub
		}
		return strings.ToUpper(sub)
	})
}

func argsToGoInOut(args []introspect.Arg) ([]arg, []arg) {
	var in, out []arg
	for i := range args {
		if args[i].Direction == "in" {
			in = append(in, newArg(args[i].Name, args[i].Type, "arg", len(in)))
		} else {
			out = append(out, newArg(args[i].Name, args[i].Type, "ret", len(out)))
		}
	}
	return in, out
}
