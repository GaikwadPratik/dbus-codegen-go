package dbusgen

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"go/format"
	"strings"

	"github.com/godbus/dbus/introspect"
)

type GeneratorOption func(g *Generator)

func WithPackageName(name string) GeneratorOption {
	if name == "" {
		panic("name is empty")
	}
	return func(g *Generator) {
		g.pkgName = name
	}
}

type Generator struct {
	pkgName string
}

func New(opts ...GeneratorOption) (*Generator, error) {
	g := &Generator{
		pkgName: "dbusgen",
	}
	for _, opt := range opts {
		opt(g)
	}
	return g, nil
}

func (g *Generator) Generate(b []byte, ifaces ...string) ([]byte, error) {
	var node introspect.Node
	if err := xml.Unmarshal(b, &node); err != nil {
		return nil, err
	}
	list := make([]introspect.Interface, 0, len(node.Interfaces))
	for _, iface := range node.Interfaces {
		if len(ifaces) > 0 && !includes(ifaces, iface.Name) {
			continue
		}
		list = append(list, iface)
	}
	return g.gen(list...)
}

func includes(ss []string, s string) bool {
	for i := 0; i < len(ss); i++ {
		if ss[i] == s {
			return true
		}
	}
	return false
}

func (g *Generator) gen(ifaces ...introspect.Interface) ([]byte, error) {
	buf := &buffer{}
	buf.writef(`// generated by dbusgen, don't edit
package %s

import "github.com/godbus/dbus"

`, g.pkgName)

	for _, iface := range ifaces {
		g.iface(buf, iface)
	}
	return format.Source(buf.bytes())
}

func (g *Generator) iface(buf *buffer, iface introspect.Interface) error {
	typ := newIfaceType(iface.Name)
	buf.writef(`// %s returns %s DBus interface implementation.
func New%s(conn *dbus.Conn, dest string, path dbus.ObjectPath) *%s {
	return &%s{conn.Object(dest, path)}
}

`, typ, iface.Name, typ, typ, typ)
	buf.writef(`// %s implements %s DBus interface.
type %s struct {
	object dbus.BusObject
}

`, typ, iface.Name, typ)

	for _, method := range iface.Methods {
		name := strings.Title(method.Name)
		in := argsToGoArgs(method.Args, "in", "arg", false)
		out := argsToGoArgs(method.Args, "out", "ret", false)
		buf.writef(`// %s calls %s.%s method.
func(o *%s) %s(%s) (%serr error) {
	err = o.object.Call("%s", 0).Store(%s)
	return
}

`, name, iface.Name, method.Name, typ, name,
			joinArgs(in, ','), joinArgs(out, ','),
			iface.Name+"."+method.Name, argsToStore(out))
	}

	for _, prop := range iface.Properties {
		method := strings.Title(prop.Name)
		if strings.Index(prop.Access, "read") >= 0 {
			retType := newSig(prop.Type)[0]
			buf.writef(`// %s gets %s.%s property.
func(o *%s) %s() (%s, error) {
	var v dbus.Variant
	if err := o.object.Call(
		"org.freedesktop.DBus.Properties.Get", 0, "%s", "%s",
	).Store(&v); err != nil {
		return %s, err
	}
	return v.Value().(%s), nil
}

`, method, iface.Name, prop.Name, typ, method, retType,
				iface.Name, prop.Name, sigZeroValue(prop.Type), retType)
		}
	}

	for _, sig := range iface.Signals {
		name := typ + strings.Title(sig.Name) + "Signal"
		args := argsToGoArgs(sig.Args, "", "prop", true)
		buf.writef(`// %s represents %s.%s signal.
type %s struct {
	%s
}

func (s *%s) Name() string {
	return "%s"
}

func (s *%s) Interface() string {
	return "%s"
}
`, name, sig.Name, iface.Name, name, joinArgs(args, ';'), name, sig.Name, name, iface.Name)
	}
	return nil
}

type buffer struct {
	buf bytes.Buffer
}

func (b *buffer) writef(format string, v ...interface{}) (int, error) {
	return fmt.Fprintf(&b.buf, format, v...)
}

func (b *buffer) bytes() []byte {
	return b.buf.Bytes()
}

func argsToStore(args []arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteByte('&')
		buf.WriteString(args[i].name)
	}
	return buf.String()
}

func joinArgs(args []arg, separator byte) string {
	var buf strings.Builder
	for i := range args {
		buf.WriteString(args[i].name)
		buf.WriteByte(' ')
		buf.WriteString(args[i].kind)
		buf.WriteByte(separator)
	}
	return buf.String()
}

func argsToGoArgs(args []introspect.Arg, direction, prefix string, export bool) []arg {
	out := make([]arg, 0, len(args))
	for i := range args {
		if direction != "" && args[i].Direction != direction {
			continue
		}
		out = append(out, newArg(args[i].Name, args[i].Type, prefix, len(out), export))
	}
	return out
}
