package dbusgen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/amenzhinsky/godbus-codegen/parser"
)

type GeneratorOption func(g *Generator)

func WithPackageName(name string) GeneratorOption {
	if name == "" {
		panic("name is empty")
	}
	return func(g *Generator) {
		g.pkgName = name
	}
}

type Generator struct {
	pkgName string
}

func New(opts ...GeneratorOption) (*Generator, error) {
	g := &Generator{
		pkgName: "dbusgen",
	}
	for _, opt := range opts {
		opt(g)
	}
	return g, nil
}

func (g *Generator) Generate(ifaces ...*parser.Interface) ([]byte, error) {
	//list := make([]*introspect.Interface, 0)
	//for _, b := range bb {
	//	var node introspect.Node
	//	if err := xml.Unmarshal(b, &node); err != nil {
	//		return nil, err
	//	}
	//	for i := range node.Interfaces {
	//		if len(ifaces) > 0 && !includes(ifaces, node.Interfaces[i].Name) {
	//			continue
	//		}
	//		list = append(list, &node.Interfaces[i])
	//	}
	//}
	return g.gen(ifaces)
}

func includes(ss []string, s string) bool {
	for i := 0; i < len(ss); i++ {
		if ss[i] == s {
			return true
		}
	}
	return false
}

func (g *Generator) gen(ifaces []*parser.Interface) ([]byte, error) {
	buf := &buffer{}
	buf.writef(`// generated by dbusgen, don't edit
package %s

import "github.com/godbus/dbus"

`, g.pkgName)

	signals := map[string][]*parser.Signal{}
	for _, iface := range ifaces {
		if err := g.iface(buf, iface, signals); err != nil {
			return nil, err
		}
	}
	if err := g.signals(buf, signals); err != nil {
		return nil, err
	}
	return format.Source(buf.bytes())
}

func (g *Generator) iface(buf *buffer, iface *parser.Interface, signals map[string][]*parser.Signal) error {
	buf.writef(`// %s returns %s DBus interface implementation.
func New%s(conn *dbus.Conn, dest string, path dbus.ObjectPath) *%s {
	return &%s{conn.Object(dest, path)}
}

`, iface.Type, iface.Name, iface.Type, iface.Type, iface.Type)
	buf.writef(`// %s implements %s DBus interface.
type %s struct {
	object dbus.BusObject
}

`, iface.Type, iface.Name, iface.Type)

	for _, method := range iface.Methods {
		buf.writef(`// %s calls %s.%s method.
func(o *%s) %s(%s) (%serr error) {
	err = o.object.Call("%s", 0).Store(%s)
	return
}

`, iface.Type, iface.Name, method.Name, iface.Type, method.Type,
			joinArgs(method.In, ','), joinArgs(method.Out, ','),
			iface.Name+"."+method.Type, argsToStore(method.Out))
	}

	for _, prop := range iface.Properties {
		method := strings.Title(prop.Name)
		if prop.Read {
			buf.writef(`// %s gets %s.%s property.
func(o *%s) %s() (%s, error) {
	var v dbus.Variant
	if err := o.object.Call(
		"org.freedesktop.DBus.Properties.Get", 0, "%s", "%s",
	).Store(&v); err != nil {
		return %s, err
	}
	return v.Value().(%s), nil
}

`, method, iface.Name, prop.Name, iface.Type, method, prop.Return,
				iface.Name, prop.Name, prop.Default, prop.Return)
		}
	}

	signals[iface.Name] = iface.Signals
	for _, sig := range iface.Signals {
		buf.writef(`// %s represents %s.%s signal.
type %s struct {
	sender string
	path   dbus.ObjectPath

	%s
}

func (s *%s) Name() string {
	return "%s"
}

func (s *%s) Interface() string {
	return "%s"
}

func (s *%s) Sender() string {
	return s.sender
}

func (s *%s) Path() dbus.ObjectPath {
	return s.path
}
`, sig.Type, sig.Name, iface.Name, sig.Type, joinArgs(sig.Args, ';'),
			sig.Type, sig.Name, sig.Type, iface.Name, sig.Type, sig.Type)
	}
	return nil
}

func (g *Generator) signals(buf *buffer, signals map[string][]*parser.Signal) error {
	if len(signals) == 0 {
		return nil
	}
	buf.writef(`// Signal is a common interface for all signals.
type Signal interface {
	Name() string
	Interface() string
	Sender() string
	Path() dbus.ObjectPath
}

`)
	buf.writef(`// LookupSignal converts the given raw DBus signal into typed one.
func LookupSignal(signal dbus.Signal) Signal {
	switch signal.Name {
`)
	for iface, sigs := range signals {
		for _, sig := range sigs {
			buf.writef(`	case "%s.%s":
		return &%s{
			sender: signal.Sender,
			path:   signal.Path,
`, iface, sig.Name, sig.Type)
			for i, arg := range sig.Args {
				buf.writef("			%s: signal.Body[%d].(%s),\n", arg.Name, i, arg.Type)
			}
			buf.writef(`		}
`)
		}
	}
	buf.writef(`	default:
		return nil
	}
}
`)
	return nil
}

type buffer struct {
	buf bytes.Buffer
}

func (b *buffer) writef(format string, v ...interface{}) (int, error) {
	return fmt.Fprintf(&b.buf, format, v...)
}

func (b *buffer) bytes() []byte {
	return b.buf.Bytes()
}

func argsToStore(args []*parser.Arg) string {
	var buf strings.Builder
	for i := range args {
		if i != 0 {
			buf.WriteByte(',')
		}
		buf.WriteByte('&')
		buf.WriteString(args[i].Name)
	}
	return buf.String()
}

func joinArgs(args []*parser.Arg, separator byte) string {
	var buf strings.Builder
	for i := range args {
		buf.WriteString(args[i].Name)
		buf.WriteByte(' ')
		buf.WriteString(args[i].Type)
		buf.WriteByte(separator)
	}
	return buf.String()
}
